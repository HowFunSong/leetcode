	


[2,3,1,1,4]

***第一種思路***

index = 4 
考慮前面的0~i-1(for i in range(i,-1,-1)) 找找看有沒有人可以到index 4
如果有，用 4- nums[i] 當成新的target ，而index j 當成新的條件，
呼叫遞迴去recursive 問前面的情況。

直到問到index[0]為止 然後更新最小step
O(n^2)


[2,3,2,1,4]
***考慮到上面例題index 2,3,都有可能跳到4，此時如果重複去問這兩個情況
，一定會發現index 3,2都會跑去問更前面的，因為需要考慮最小step 故到3不能從2過來否則必定+1。

是否可以記錄一個目前最遠且最小step去得到最佳解???
	farest = 0
	minimal step = 0
	dp = [0,0,0,0,0]
 
	[2,3,2,1,4]
	a[0] = 2 	
	if dp[0+a[0]==0  dp[0+a[0]]=dp[0]+1, 
	elsedp[0+a[0]]=min(dp[0]+1,dp[0+a[0]])    
	[0,0,1,0,0]
	farest = max(farest,a[0+a[0])=2

	a[1] = 3  
	[0,0,1,0,2] -----卡住變成dp[1]也要先更新==>概念上也是要用一個whileloop去更新


=============================


第三種思路:

考慮第一種，現在的想法是找到一條可以到達最後一個元素的最短路徑

因此從後面往前追，每次都去看 i+num[i]能否到達index dp[i+1] 的之中最短路徑

ex    		[  2  ,  3  ,  2  ,  1  ,  4  ]
	dp             [  0  ,  0  ,  0  ,  0  ,  0]
		[  0  ,  0  ,  0  ,  1  ,  0]

		if index +nums[index]>=4 dp[index] = 1 else dp[index]=dp[index+1]+1
		[  0  ,  0  ,  1  ,  1  ,  0]
		[  0  ,  1  ,  1  ,  1  ,  0]

		if index +nums[index]>=4 dp[index] = 1 else dp[index]=dp[index+1]+1
		[  1  ,  1  ,  1  ,  1  ,  0]


		

ex		[  2  ,  3  ,  1  ,  1  ,  4  ]

		   [  0  ,  0  ,  0  ,  1  ,  0]
   		  [  0  ,  0  ,  2  ,  1  ,  0]
   		[  0  ,  1  ,  2  ,  1  ,  0]
		[  2  ,  1  ,  2  ,  1  ,  0]

		

		[  2  ,  1  ,  1  ,  1  ,  4  ]
	dp	 [  0  ,  0  ,  0  ,  1  ,  0]
		 [  0  ,  0  ,  2  ,  1  ,  0]
		 [  0  ,  3  ,  2  ,  1  ,  0]
		[  0  ,  3  ,  2  ,  1  ,  0]
		[  3  ,  3  ,  2  ,  1  ,  0]

		[  2  ,  1  ,  2  ,  1  ,  4  ]

	             dp[  0  ,  0  ,  0  ,  1  ,  0]
		 [  0  ,  2  ,  1  ,  1  ,  0]
		 [  0  ,  2  ,  1  ,  1  ,  0]
		[  0  ,  2  ,  1  ,  1  ,  0]
		[  2  ,  2  ,  1  ,  1  ,  0]











